// Auto-generated by Java-to-Swift wrapper generator.
import AndroidJavaIO
import JavaKit
import JavaKitFunction
import JavaRuntime

@JavaClass("java.util.regex.Pattern", implements: Serializable.self)
open class Pattern: JavaObject {
  @JavaMethod
  open override func toString() -> String

  @JavaMethod
  open func flags() -> Int32

  @JavaMethod
  open func matcher(_ arg0: CharSequence?) -> Matcher!

  @JavaMethod
  open func split(_ arg0: CharSequence?, _ arg1: Int32) -> [String]

  @JavaMethod
  open func split(_ arg0: CharSequence?) -> [String]

  @JavaMethod
  open func splitWithDelimiters(_ arg0: CharSequence?, _ arg1: Int32) -> [String]

  @JavaMethod
  open func pattern() -> String

  @JavaMethod
  open func namedGroups() -> Map<JavaString, JavaInteger>!

  @JavaMethod
  open func asPredicate() -> JavaPredicate<JavaString>!

  @JavaMethod
  open func asMatchPredicate() -> JavaPredicate<JavaString>!

  @JavaMethod
  open func splitAsStream(_ arg0: CharSequence?) -> Stream<JavaString>!
}
extension JavaClass<Pattern> {
  @JavaStaticField(isFinal: true)
  public var UNIX_LINES: Int32

  @JavaStaticField(isFinal: true)
  public var CASE_INSENSITIVE: Int32

  @JavaStaticField(isFinal: true)
  public var COMMENTS: Int32

  @JavaStaticField(isFinal: true)
  public var MULTILINE: Int32

  @JavaStaticField(isFinal: true)
  public var LITERAL: Int32

  @JavaStaticField(isFinal: true)
  public var DOTALL: Int32

  @JavaStaticField(isFinal: true)
  public var UNICODE_CASE: Int32

  @JavaStaticField(isFinal: true)
  public var CANON_EQ: Int32

  @JavaStaticField(isFinal: true)
  public var UNICODE_CHARACTER_CLASS: Int32

  @JavaStaticMethod
  public func matches(_ arg0: String, _ arg1: CharSequence?) -> Bool

  @JavaStaticMethod
  public func compile(_ arg0: String) -> Pattern!

  @JavaStaticMethod
  public func compile(_ arg0: String, _ arg1: Int32) -> Pattern!

  @JavaStaticMethod
  public func quote(_ arg0: String) -> String
}
